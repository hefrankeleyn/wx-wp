# 小程序的运行机制

[toc]

## 一、启动机制和两种状态

小程序启动会有两种情况：

• 「冷启动」

> 已经打开过，（一定时间）再次打开，无需重新启动。

• 「热启动」

> 首次打开，或者小程序被微信销毁关闭再次打开，重新加载启动。

发布了新的版本，小程序何时会使用新的版本。

- 小程序冷启动，如果发现有新的版本，将会异步下载新版本的代码包。并且同时使用客户端本地的代码包进行启动。新版本的小程序需要等下一次冷启动时才会用上。
- 如果马上想用最新版本的代码包，可以使用`wx.getUpdateManager`这个接口进行处理。

与冷热启相关，小程序有两种状态：

- 前台状态：小程序被启动，前台页面展示给用户，此时小程序处于前台状态。

- 后台状态：当用户点击右上角按钮，关闭小程序之后。或按了设备的Home键，离开微信小程序并没有终止运行，小程序还可以运行一段时间，这是进入了后台状态。

  （热启动机制）当再次打开小程序或打开微信，小程序又会切回到前台状态。

## 二、小程序的启动情况：三种

第一种：首次打开小程序，从微信云端下载小程序代码包并进行运行；

第二种：（热启动）最近启动过小程序，直接将小程序从后台状态切到前台状态；

第三种：（冷启动）长时间未运行或被微信主动销毁之后再次打开，这个时候从本地缓存读取代码包，同时从微信云端检测新版本，如果有更新就进行下载。

## 三、小程序主动被销毁：两种情况

第一种：当小程序进入后台，在后台维持运行，超过一定时间，大概是五分钟，就会被微信主动销毁；

第二种：当短时间内（目前为5秒），连续两次以上收到系统内存的警告，微信就会对小程序进行一个主动地销毁。

这时候一般我们会收到这样的提示语“运行内存不足，请重新打开小程序。”，单击确定之后，小程序就直接退出了。这种体验对用户很不友好。必要的时候可以使用`wx.onMemoryWarming`接口监听内存接口的告警事件，提前做一些处理。

## 四、小程序的双线程架构

### （1）视图线程和逻辑线程

为了安全和管控，小程序使用双线程执行：视图线程和逻辑线程。

- View 视图线程

  负责视图层，主要提供各类组件、渲染页面。

- App Service 逻辑线程

  提供各种API处理业务逻辑。

这两者通过底层微信的`WeixinJSBridge`进行通信。

### （2）视图的持续更新怎么实现

通过`setData`实现：

```javascript
webView.evaluateJavaScripte("javaScript: 方法名()", new ValueCallback<string>(){
                            @Override
                            public void onReceiveValue(String value) {
                                //...
                            }
                            });
```

在程序中，视图层和逻辑层的数据传输是通过底层的`WeixinJSBridge`实现，也就是通过原生的`evaluateJavaScripte`实现。

### （3）`setData`会遇到什么问题

视图和逻辑两个线程，通过前置的`setData`方法交互，驱动数据通过`WeixinJSBridge`进行中转，中转的效率是极其低下的。

所以，安卓上的微信小程序会卡顿，这是因为视图线程一直在努力进行渲染，逻辑层发来的更新请求被阻塞了。当这种阻塞达到200毫秒，视图渲染便会卡顿。

机器性能越差，卡顿越明显。

卡断不仅与更新的频率有关，也与更新的数据量有关。当使用`setData`更新一个大的数据表，或一个很大的图片时，也会卡断。

在IOS系统中，小程序的页面是由多个WKWebView组成，在系统内存紧张时一部分WKWebView会被系统回收掉，也即是曾经打开的小程序界面将会退出历史记录。这些界面就无法回退了。

### （4）微信为何打造一个WXS语言

WXS是微信打造的小程序脚本语言，WXS结合WXML可以构建出页面的组件结构。

WXS不依赖于运行时的基础库版本，所以可以在所有版本的小程序里面运行。

WXS直接运行在视图层，避免了跨线程的通信开销。

因为小程序双线程在视图更新上有瓶颈，所以微信打造了一个WXS语言。

WXS的缺陷：

1. WXS运行环境与其它JS代码是隔离的；

2. WXS函数不能作为视图模版中的事件回调橘句柄；

3. WXS在IOS设备上比JS快20倍；

   在安卓上，执行效率基本一样。

## 五、视图线程

### （1）视图组件

与小程序视图线程相关的编译器有两个：

- WCC编译器

  WCC时WXML编译器，用于把WXML文件编译成js代码。

- WCSC编译器

  WCSC是WXSS编译器，用于把WXSS文件编译成js代码。

小程序的视图层是在Polymer框架的基础之上，基于Web Component标准实现的。

当WXML和WXSS文件编译完成之后，会在内存中创建一个虚拟的DOM。虚拟DOM可以看作是一个内存中的UI组件库。

使用虚拟DOM是为了提高视图的渲染效率。

### （2）原生组件

小程序把视图组件放在下面，把解析出来的原生组件放在下面。

原生组件永远放在一般视图组件上面。

## 六、逻辑线程

### （1）逻辑线程生命状态图

在小程序的生命周期中，有五个生命周期函数：

| 生命周期函数 | 作用                         |
| ------------ | ---------------------------- |
| onLoad       | 当页面加载时                 |
| onShow       | 当页面显示出来并对用户可见时 |
| onReady      | 当页面初次渲染完成时         |
| onHide       | 当页面被隐藏时               |
| onUnload     | 当页面被卸载时               |

微信小程序有五个生命周期函数，这些函数在小程序的不同阶段会被自动触发，允许开发者在特定的时机执行相应的逻辑操作。以下是这五个生命周期函数：

1. **onLoad(options)：** 当页面加载时，`onLoad`生命周期函数会被触发。在这个函数中，你可以获取到页面的参数（通过`options`参数传递），并进行相应的初始化工作。
2. **onShow()：** 当页面显示出来并对用户可见时，`onShow`生命周期函数会被触发。这个函数通常用于页面切换、返回时的一些操作，例如数据更新或刷新。
3. **onReady()：** 当页面初次渲染完成时，`onReady`生命周期函数会被触发。在这个时候，页面的视图层已经准备好，可以执行一些需要操作DOM元素的初始化工作。
4. **onHide()：** 当页面被隐藏时，例如用户切换到其他页面时，`onHide`生命周期函数会被触发。你可以在这个函数中暂停一些活动，例如停止定时器或清理数据。
5. **onUnload()：** 当页面被卸载时，例如用户退出页面或返回到上一页时，`onUnload`生命周期函数会被触发。这个函数通常用于清理一些不再需要的资源和数据。

这些生命周期函数允许开发者在不同的页面状态下执行特定的操作，以提供更好的用户体验和管理页面的生命周期事件。在小程序开发中，了解这些生命周期函数的使用方法和时机是很重要的。

### （2）逻辑线程的四个状态

逻辑线程的四个状态

- 初始化状态

  78 启动服务线程所需的基本功能。系统的初始化工作完毕会调用自定义的`onLoad`和`onShow`，然后等待界面线程的初始化完成信号。

  `onLoad`只在首次渲染时，执行一次。

  `onShow`在界面每次切换的时候，都会执行。

- 等待激活状态

  接收到视图线程初始化完成信号后，将初始化数据发送给视图线程。等待界面完成初始渲染。

- 激活状态

  收到界面线程发送过来的首次渲染完成信号后，就进入激活状态。即程序的正常运行状态。并调用自定义的onReady函数。在这个状态下可以调用`setData`函数，发送更新数据给视图线程以更新页面。

- 后台运行状态

  如果页面进入后台，服务线程就进入后台运行状态。这种状态下也可以通过　`setData`函数更新视图数据。但这种更新是我们应该避免的。

